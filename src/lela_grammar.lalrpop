use crate::lela::{ProgramEntry, Definition, Expression, Operator, Value};

grammar;

pub DefinitionOrExpression: Box<ProgramEntry> = {
    <Definition>,
    <Expr> => Box::new(ProgramEntry::Expression(<>))
}

Definition: Box<ProgramEntry> = {
    ConstantDefinition,
    FunctionDefinition
}

ConstantDefinition: Box<ProgramEntry> = {
    "let" <ident:Identifier> "=" <exp:Expr> => 
        match *ident {
            Expression::Identifier(name) => Box::new(ProgramEntry::Definition(Definition::ConstantDefinition(name, exp))),
            _ => unreachable!("did not parse as identifier")
        }
    
}

FunctionDefinition: Box<ProgramEntry> = {
    "func" <ident:IdentifierToken> "(" <params: ListEntries> ")" "{" <answer:Expr> "}" => {
        let mut string_params: Vec<String> = Vec::new();
        for expr in params {
            match *expr {
                Expression::Identifier(name) => string_params.push(name),
                _ => {}
            }
        }
        Box::new(ProgramEntry::Definition(Definition::FunctionDefinition(ident, string_params, answer)))
    }
}

Expr: Box<Expression> = {
    Term,
    Identifier,
    "(" <a:Expr> <op:ExprOp> <b:Expr> ")" => Box::new(Expression::Operation(op, a, b)),
    "[" <list:ListEntries> "]" => Box::new(Expression::List(list)),
    FunctionExpression,
    ConditionalExpression
};

ConditionalExpression: Box<Expression> = {
    <IfExpression>,
    <ConditionalTreeExpression>
}

IfExpression: Box<Expression> = {

    "if" <condition: Expr> "{" <then: Expr> "}" "else" "{" <otherwise: Expr> "}" => {
        let cases = vec![condition, Box::new(Expression::ValueExpr(Value::Boolean("#true".to_string())))];
        let values = vec![then, otherwise];
        Box::new(Expression::ConditionalTree(cases, values))
    }
}

//
ConditionalTreeExpression: Box<Expression> = {
    "switch" "{" <cases: ConditionalTreeBranch+> "}" => {
        // There's likely some more 'rusty' way to handle this
        let mut conditions = Vec::new();
        let mut values = Vec::new();
        for (cond, value) in cases.into_iter() {
            conditions.push(cond);
            values.push(value);
        }
        Box::new(Expression::ConditionalTree(conditions, values))
    }
}

ConditionalTreeBranch: (Box<Expression>, Box<Expression>) = {
    "case" <cond: Expr> ":" <value: Expr> "," => (cond, value)
}

// Expressions:
FunctionExpression: Box<Expression> = {
    <name:Identifier> "(" <params:ListEntries> ")" => {
        // we must hope that lalrpop doesn't put something other than an 
        // identifier expression in a function call
        match *name {
            Expression::Identifier(x) => Box::new(Expression::FunctionCall(x, params)),
            _ => panic!("somehow a function call was parsed that involves a name that isn't an identifier")
        }
    }
}

ExprOp: Operator = {
    "+" => Operator::Add,
    "-" => Operator::Subtract,
    "*" => Operator::Multiply,
    "/" => Operator::Divide,
    "&&" => Operator::And,
    "||" => Operator::Or,
    "==" => Operator::Equals,
};


ListEntries: Vec<Box<Expression>> = {
    <first:Expr> <rest:ListEntry*> => {
            // It's possible that this may be quicker if this function were
            // a vector containing only first then was appended the rest.
            // This runs in O(N) time with n being how many elements are in rest
            let mut new_rest = rest;
            new_rest.insert(0, first);
            new_rest
        }
}

IdentifierToken: String = {
    r"[A-Za-z]+[A-Za-z0-9?_-]*" => <>.to_string()
}

Identifier: Box<Expression> = {
   <i:IdentifierToken> => Box::new(Expression::Identifier(i))
}

ListEntry: Box<Expression> = {
    "," <e:Expr> => e
}



Term: Box<Expression> = {
    Num => Box::new(Expression::ValueExpr(Value::Number(<>))),

    r"#true" => Box::new(Expression::ValueExpr(Value::Boolean(<>.to_string()))),
    r"#false" => Box::new(Expression::ValueExpr(Value::Boolean(<>.to_string()))),
    "(" <Expr> ")"
};


// Maximum: 4294967296 possible integers
// supports numbers between -2,147,483,647 and 2,147,483,647
// which, in my opinion, is a reasonable amount at the moment
Num: String = {
    r"[-]?[0-9]+" => <>.to_string(),
};
