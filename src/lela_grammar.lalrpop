use crate::lela::{ProgramEntry, Definition, Expression, Operator, Value, FunctionObject};
use crate::lela;

grammar;

pub DefinitionOrExpression: Box<ProgramEntry> = {
    <Definition>,
    <Expr> => Box::new(ProgramEntry::Expression(<>))
}

Definition: Box<ProgramEntry> = {
    ConstantDefinition,
    FunctionDefinition,
    StructDefinition
}

StructDefinition: Box<ProgramEntry> = {
    "struct" <name:IdentifierToken> "[" <fields:ListEntries<IdentifierToken>> "]" => {
        Box::new(ProgramEntry::Definition(Definition::StructDefinition(name, fields)))
    }
}

ConstantDefinition: Box<ProgramEntry> = {
    "let" <ident:IdentifierToken> "=" <exp:Expr> =>
            Box::new(ProgramEntry::Definition(Definition::ConstantDefinition(ident, exp)))
}

FunctionDefinition: Box<ProgramEntry> = {
    "func" <ident:IdentifierToken> "(" <params: ListEntries<IdentifierToken>> ")" "{" <answer:Expr> "}" => {
        let mut string_params: Vec<String> = Vec::new();
        for name in params {
            string_params.push(name)
        }
        Box::new(ProgramEntry::Definition(Definition::FunctionDefinition(ident, string_params, FunctionObject::new(move |_| Ok(answer.clone())))))
    }
}

Expr: Box<Expression> = {
    Term,
    Identifier,
    "(" <a:Expr> <op:ExprOp> <b:Expr> ")" => Box::new(Expression::Operation(op, a, b)),
    "[" <list:ListEntries<Expr>> "]" => Box::new(lela::vec_to_pair_list(&list)),
    FunctionExpression,
    ConditionalExpression
};

ConditionalExpression: Box<Expression> = {
    <IfExpression>,
    <ConditionalTreeExpression>
}

IfExpression: Box<Expression> = {

    "if" <condition: Expr> "{" <then: Expr> "}" "else" "{" <otherwise: Expr> "}" => {
        let cases = vec![condition, Box::new(Expression::ValueExpr(Value::Boolean("#true".to_string())))];
        let values = vec![then, otherwise];
        Box::new(Expression::ConditionalTree(cases, values))
    }
}

ConditionalTreeExpression: Box<Expression> = {
    "switch" "{" <cases: ConditionalTreeBranch+> "}" => {
        // There's likely some more 'rusty' way to handle this
        let mut conditions = Vec::new();
        let mut values = Vec::new();
        for (cond, value) in cases.into_iter() {
            conditions.push(cond);
            values.push(value);
        }
        Box::new(Expression::ConditionalTree(conditions, values))
    }
}

ConditionalTreeBranch: (Box<Expression>, Box<Expression>) = {
    "case" <cond: Expr> ":" <value: Expr> "," => (cond, value)
}

// Expressions:
FunctionExpression: Box<Expression> = {
    <name:Identifier> "(" <params:ListEntries<Expr>> ")" => {
        // we must hope that lalrpop doesn't put something other than an 
        // identifier expression in a function call
        match *name {
            Expression::Identifier(x) => Box::new(Expression::FunctionCall(x, params)),
            _ => panic!("somehow a function call was parsed that involves a name that isn't an identifier")
        }
    }
}

ExprOp: Operator = {
    "+" => Operator::Add,
    "-" => Operator::Subtract,
    "*" => Operator::Multiply,
    "/" => Operator::Divide,
    "and" => Operator::And,
    "or" => Operator::Or,
    "is" => Operator::Equals,
};






ListEntries<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

IdentifierToken: String = {
    r"[A-Za-z]+[A-Za-z0-9?_\/.\\-]*" => <>.to_string()
}

Identifier: Box<Expression> = {
   <i:IdentifierToken> => Box::new(Expression::Identifier(i))
}



Term: Box<Expression> = {
    Num => Box::new(Expression::ValueExpr(Value::Number(<>))),

    r"#true" => Box::new(Expression::ValueExpr(Value::Boolean(<>.to_string()))),
    r"#false" => Box::new(Expression::ValueExpr(Value::Boolean(<>.to_string()))),
    "(" <Expr> ")"
};


// Maximum: 4294967296 possible integers
// supports numbers between -2,147,483,647 and 2,147,483,647
// which, in my opinion, is a reasonable amount at the moment
Num: String = {
    r"[-]?[0-9]+" => <>.to_string(),
};
