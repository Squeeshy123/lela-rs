use std::str::FromStr;
use crate::lela::{Scope, ProgramEntry, Definition, Expression, Operator, Value};

grammar;

pub DefinitionOrExpression: Box<ProgramEntry> = {
    <Expr> => Box::new(ProgramEntry::Expression(<>)),
    <Definition>
}

Definition: Box<ProgramEntry> = {
    ConstantDefinition,
    FunctionDefinition
}

ConstantDefinition: Box<ProgramEntry> = {
    "let" <ident:Identifier> "=" <exp:Expr> => 
        match *ident {
            Expression::Identifier(name) => Box::new(ProgramEntry::Definition(Definition::ConstantDefinition(name, exp))),
            _ => unreachable!("did not parse as identifier")
        }
    
}

FunctionDefinition: Box<ProgramEntry> = {
    "func" <ident:IdentifierToken> "(" <params: ListEntries> ")" "{" <answer:Expr> "}" => {
        let mut string_params: Vec<String> = Vec::new();
        for expr in params {
            match *expr {
                Expression::Identifier(name) => string_params.push(name),
                _ => {}
            }
        }
        Box::new(ProgramEntry::Definition(Definition::FunctionDefinition(ident, string_params, answer)))
    }
}

Expr: Box<Expression> = {
    "(" <a:Expr> <op:ExprOp> <b:Expr> ")" => Box::new(Expression::Operation(op, a, b)), 
    "[" <list:ListEntries> "]" => Box::new(Expression::List(list)),
    FunctionExpression,
    Term,
    Identifier
};

// Expressions:
FunctionExpression: Box<Expression> = {
    <name:Identifier> "(" <params:ListEntries> ")" => {
        // we must hope that lalrpop doesn't put something other than an 
        // identifier expression in a function call
        match *name {
            Expression::Identifier(x) => Box::new(Expression::FunctionCall(x, params)),
            _ => panic!("something terribly wrong has happened...")  
        }
    }
}

ExprOp: Operator = {
    "+" => Operator::Add,
    "-" => Operator::Subtract,
    "*" => Operator::Multiply,
    "/" => Operator::Divide,
};


ListEntries: Vec<Box<Expression>> = {
    <first:Expr> <rest:ListEntry*> => { 
            let mut new_rest = rest;
            new_rest.insert(0, first);
            new_rest
        }
}

IdentifierToken: String = {
    r"[A-Za-z]+[A-Za-z0-9?_-]*" => <>.to_string()
}

Identifier: Box<Expression> = {
   <i:IdentifierToken> => Box::new(Expression::Identifier(i))
}

ListEntry: Box<Expression> = {
    "," <e:Expr> => e
}



Term: Box<Expression> = {
    Num => Box::new(Expression::ValueExpr(Value::Number(<>))),
    "(" <Expr> ")"
};


// Maximum: 4294967296 possible integers
// supports numbers between -2,147,483,647 and 2,147,483,647
// which, in my opinion, is a reasonable amount at the moment
Num: String = {
    r"[-]?[0-9]+" => <>.to_string()
};
